## C++11新特性：

### 1. `auto`关键字

- 使用方法：可以在编译时由编译器自动推导变量类型；常用于定义迭代器变量；
- 注意：
	1. auto不能作为函数参数使用；
	2. auto不能用作定义数组；
	3. 使用auto定义变量，变量必须初始化；

### 2. `decltype`关键字

- 使用方法：类似auto关键字，可以自动推导出函数的返回值类型,适用与调用函数模板时，返回值类型为T时不好确定的情况；例如：
```c++
void* fun（int a）{
	return malloc(a);
}
decltype(fun(0)) re = fun(100);
```

### 3. 基于范围的for循环

- 使用方法：for(循环的变量：要遍历的容器){ }，例如：
```
1.简单输出集合中的内容
vector<int> set = {1,2,3,4,5};
for (auto i :set){
	cout << i;
}   //i是遍历得到的set中的元素；
2.如果要修改集合中的元素，可以将i声明为引用；
for (auto &i :set){
	i++;
} 
```

### 4. 通过using为类型定义别名

- 使用方法：对于复杂的类型，需要多次构造该类型对象时，可以通过using为类型起一个别名，简化代码，例如：
```c++
using map_int = std::map<string, int>;
map_int a = { {"a",1}};
```

### 5. final关键字

- 使用方法：
	1. 用final修饰类，则该类不可被继承；用于设计保护线程安全的类；
	2. 用final修饰虚函数，则虚函数不可被子类重写；如果基类中的某个函数所执行的功能，对所有派生类来说都是一样的，都具有这一功能，并没有任何区别，则这时候就需要将这个函数用final来修饰；

### 6. 右值引用

- 左值和右值的概念：左值其实就是能够或取得到地址的变量，右值是不能获取得到地址的，只能读它的值，而不能修改它的值；
- 右值引用：
	1. 右值引用只能通过右值进行初始化，不能通过右值引用进行初始化；例：
	```c++
	int&& a = 5;  //a是右值引用
	int&& b = a;  //错误，不能用右值引用初始化;
	```
	2. 右值引用的应用场景：
	    (1) 延长临时对象的生命周期；
	    (2) 实现移动构造函数；
	3. &&特性：在C++中，并不是所有&& 都表示右值引用；例如在模板类型推导中T&&，只有当其被右值初始化时，T&&才是右值引用类型，否则都是左值引用；但是`const T&&`一定是右值引用类型；

### 7. move(转移)函数：

- 作用：将一个参数转换为右值引用类型，从而支持移动语义；即能够将参数的资源进行转移；move(非右值) 得到的是一个右值引用类型，可以用来给右值引用初始化；  使用完move之后，原对象会处于有效但未定义的状态，也就是说对象没有被销毁仍然存在，可以对其赋值或者销毁，但是尽量不要使用原对象的值，否则可能会出问题；

### 8. forward(完美转发)函数：

- 作用：防止参数在传递过程中发生类型转换 `forword<T>`(参数t) 
- 使用：<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240421170024919.png" alt="image-20240421170024919" style="zoom:67%;" />



### 9. `constexpr `关键字：

- 声明变量或函数为常量表达式，使在编译时就计算常量表达式的值，提高程序的性能和效率；
- `constexpr` 变量必须在声明时就被初始化。
- `constexpr` 声明函数时函数的参数和返回值必须是字面值类型

### 10. `Lanmbda`表达式 ：

- 作用：一种语法糖，用于书写匿名函数，简化代码；

- 语法格式：(参数列表) => 表达式或语句块；当参数列表只有一个参数时，可以将括号省略，如果没有参数，使用 () 或者 _；例：

  ```c#
  // 1.没有参数
  () => Console.WriteLine("Hello, world!");  //单语句，如果是语句块得用{ }括起来
  // 2. 1个参数
  x => x * x;
  // 3. 多个参数
  (x,y) => x*y;
  // 函数体为语句块
  (x, y) => 
  { 
  	int sum = x + y; 
  	Console.WriteLine(sum); 
  }
  ```

### 11. 智能指针（类）：

- 作用：**智能指针就是为了管理指针**，由于c++没有垃圾回收机制，必须自己释放申请的内存，否则会造成内存泄漏，通过`new`--`delete`和`malloc`--`free`可以申请内存和释放内存，区别是`new`--`delete`会自动调用构造函数和析构函数，`malloc`--`free`则不会；

- #### `shared_ptr`（共享的智能指针）：

  - **作用：**对个共享智能指针可以同时管理同一块内存，此时，在共享指针内部会有一个引用计数，记录管理这块内存的指针的数量，当有一个指针被析构或重置时，引用计数会减一，当最后一个指针析构时，就会将当前这块内存也析构掉；
  - **初始化**：有4种初始化方式

  ```c++
  // 1.通过构造函数进行初始化  std::shard_ptr<T> 名称();
  shared_ptr<int> ptr1(new int(520)); 
  
  // 2.通过拷贝构造函数或移动构造函数
  // 拷贝构造
  shared_ptr<int> ptr2 = ptr1; 或者  shared_ptr<int> ptr2(ptr1);   //此时ptr2和ptr1管理同一块内存
  //移动构造
  shared_ptr<int> ptr3 = std::move(ptr1) 或者shared_ptr<int> ptr3(std::move(ptr1)); //将ptr1管理的内存转移给了ptr3
  
  // 3.通过std::make_shared()函数进行构造
  shared_ptr<int> ptr1 = make_shared<int>(520);
  
  // 4.通过reset()方法进行初始化
  //reset() 方法有两个作用，第一个是让指向某块内存的智能指针接触对该内存的管理；第二个是可以让该智能指针指向另一块内存；
  ptr1.reset(); //让ptr1不再管理那块内存
  ptr1.reset(new int(250)); //让ptr1指向一块新内存；
  
  // 5.获取原始指针，可使用get方法
  shared_ptr<char> ptr(new char[100]);
  // 得到指针的原始地址，实际上智能指针ptr管理的是指针add，add管理的是该内存
  char* add = ptr.get();
  ```

  - **删除器函数**：当智能指针管理的内存不是数组时，智能指针会自动调用其内部的删除器函数，如果管理的内存是数组时，智能指针的内部的删除器不能释放掉该内存，需要自己指定删除器函数;**c++11后的版本优化了这一点，管理数组类型的内存时不再需要指定删除器函数**

  ```c++
  //1.自己写删除器函数，可以用lambda表达式，写一个匿名函数，创建智能指针时，第二个参数就是删除器函数
  shared_ptr<int> ptr(new int[10], [](int* p) {delete[]p; });
  
  //2.使用系统提供的删除器函数std::default_delete<T>()；
  shared_ptr<int> ptr(new int[10], default_delete<int[]>());
  ```

  - **注意事项**：<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240421191133279.png" alt="image-20240421191133279" style="zoom:50%;" />

- #### `unique_ptr`（独占的智能指针）：

  - **作用：**一块内存智能被一个独占的智能指针管理，如果有新的独占智能指针需要管理这块内存时，就需要使用move进行资源的转移；
  - **初始化：**相比共享智能指针，独占智能指针智能自己管理一块内存，所以不能使用拷贝构造进行初始化

  ```c++
  // 1.通过构造函数进行初始化  std::unique_ptr<T> 名称();
  unique_ptr<int> ptr1(new int(520)); 
  
  // 2.通过move方法;
  unique_ptr<int> ptr2 = move(ptr1);  //或者也可以使用一个临时对象为其初始化；比如有一个函数的返回值是独占共享指针类型的
  
  // 3.reset()方法;
  ptr2.reset(new int(8));
  
  ```

- #### `weak_ptr`（弱引用的智能指针）：

  - **作用：** **`weak_ptr` 是⽤来解决 `shared_ptr` 相互引用时的死锁问题**，它不能操作资源，是对对象的⼀种弱引⽤，是用来监视`shared_ptr`的；可以用一个`shared_ptr`类型的对象为其初始化，相当于用一个`weak_ptr`对象去检测`shared_ptr`所管理的那块内存；`shared_ptr `可以直接赋值给它，它可以通过调⽤` lock `函数来获得` shared_ptr`。

## 基础语法：

### **常用关键字**

#### 1. `extern`关键字：

- **作用：**用于声明外部变量或函数，表名该变量或函数的的定义在其它文件中，函数声明时可以省略； 如何同一个变量在多个文件中被使用，则只能在一个文件中定义，在其它需要使用的文件中声明（添加`extern`），即可使用该变量。

#### 2. `const`关键字：声明常量

- ##### **作用：**

  1. 将变量申明为常量，防止变量的值被修改；

  2. 保护参数，在函数的传入参数前加上`const`，表示该参数在函数内部是只读的；
  3. 修饰类中的成员函数：防止成员函数修改对象的内容；

- ##### **修饰指针：**

  1. 常量指针：该指针是个常量，也就是不能修改指针的值，即不能修改指针所指向的对象；写法：`int *const p`
  2. 指针常量：该指针指向了一个常量，也就是不能修改指针所指向的对象的值，但可以修改指针指向，即可以修改指针的值；写法：`const int *p`

- **修饰引用：**

  1. 常量左值引用：表示不能通过引用修改变量的值，用于在函数传参过程中防止引用对象被修改；同时常量引用的引用对象可以是常量也可以是非常量,甚至可以是右值引用或者常量右值引用；例如:

```c++
int sum = 5;     
const int sum2 = 5;  //常量
//常量左值引用
const int& a = sum；  
sum = 10;   //正确
a = 10；    //错误

const int& b = sum2；   //正确
//但是常量对象不能被非常量引用所引用
int& c = sum2;       //错误
```

#### 3. `Static`关键字：控制变量的存储方式和可见性

- **作用一：修饰局部变量** ，局部变量本来是存放在栈区，添加`static`之后就从栈区移到了静态存储区，该变量的生命周期也就相应的进行了改变，会一直存在到程序结束；但是变量的作用域不会改变，还是在其语句块内；
- **作用二：修饰全局变量**，当用`static`修改全局变量时，该全局变量的作用范围就会变为本文件内可用，不能被其它文件访问（可以通过extern修饰后读取这个变量的值，但是不能修改值）；正常的全局变量在整个项目内都可以访问，但是如果不是本文件，需要加`extern`关键字来声明；
- **作用三：修饰类的成员函数**，当类中的成员函数被`static`修饰之后，该函数就变成了类的函数，而不是对象的函数，就可以直接直接通过类名来调用；相对于所有的对象都共用一个函数（修饰成员变量也同理，但是**static修饰的成员变量必须在类外初始化**）；**静态函数不能访问非静态成员变量和函数**，因为它们没有this指针。





### 重要知识点

#### 1. 引用：

1. 引用不是对象，在声明时必须初始化，一旦初始化，则无法修改；
2. 给引用赋值，其实就是给引用的对象赋值；
3. 引用本身并没有实际地址；
4. 引用的意义或作用：主要是为了在函数的传参过程中避免对象的拷贝；因为如果一个变量作为函数参数时，不管是使用指针传递或者值传递(或者作为函数返回值时)，都会发生**对象的拷贝**，会消耗系统资源，而引用则不会；

#### 2. 指针：

1. 指针是一个对象，存放的是指针指向的对象的地址；
2. 因为引用本身不是一个对象，因此不能定义指向引用的指针，但是可以定义指针的引用；

```

```

#### 3. C++中的内存分配

	1. 分为：栈区、堆区、全局/静态存储区（存放全局变量和静态变量）、常量区、代码区；
	1. 栈区由**编译器**负责分配，堆区由程序员手动分配并释放；
	1. 常量区存放常量和**字符串**，一般不允许修改
	1. 代码区存放二进制代码；

## 常见面试题

### 一、网络编程方面

#### 1.`GET`和`POST`的区别(HTTP协议)

- GET用于向服务器请求数据，参数通过URL传递，请求的数据会以明文的形式出现在URL中，有安全隐患且有长度限制；
- POST用于向服务器提交数据：参数在URL中不可见，没有安全隐患，且请求的数据量可以比较大；
- URL是资源定位符，用于标识和定位互联网上的资源，包含了该资源的协议信息，主机名，端口号，路径等信息；

### 二、多线程/进程(`IPC`)方面

#### 1.进程间通讯如何实现：

- 进程间通讯的方法有：管道、套接字`socket`、消息队列
  1. 管道（半双工，单向通信）：管道分为无名管道和有名管道
     - 无名管道：只能用于父子进程或者兄弟进程间进行通信；无名管道的数据流是先进先出（FIFO）的，即先写入的数据先被读取。
     - 有名管道：允许任意两个进程间通信；
  2. 消息队列：允许不相关的进程通过消息进行通信。进程可以将消息发送到队列中，然后其他进程可以从队列中读取消息。消息队列可以提供多种消息传递模式，如先进先出（FIFO）和优先级。
  3. 套接字：套接字主要用于网络通信，也可以用于同一台主机间的进程通信；

### 三、设计模式

#### 1.代理模式：

- 允许在某些对象（代理对象）控制另外一个对象的访问。代理通常充当客户端和实际对象之间的中介，以控制客户端对实际对象的访问；

#### 2.工厂模式：

- 将创建对象的过程封装到专门的工厂类中，用工厂类代替new操作；分为：简单工厂模式、工厂方法模式和抽象工厂模式

#### 3.单例模式：

- 一个类只能创建一个对象，适用于比如：线程池、缓存、网络请求
- 实现方法：
  1. 将构造函数声明为private，避免外部new操作；
  2. 通过一个静态方法或者枚举返回一个单例对象；
- 分类：饿汉式和懒汉式
  1. 饿汉式是指在类加载时就会创建了一个该类的对象，然后可以通过一个静态函数将对象返回，是线程安全的；但是可能会造成资源浪费，因为无论是否使用该单例对象，都会创建实例。
  2. 懒汉式是在使用时才会创建对象，线程不安全，如果多个线程同时调用获取单例实例的方法，可能会创建多个实例；
