# 一、常见数据结构

## `C++STL`下常用容器

### 1. vector(动态数组)

- 支持随机访问和动态增删元素；适用存储数据量小，并且不用频繁修改的数据

#### 优点

1. 可以通过索引随机的访问元素；
2. 在尾部插入和删除元素不需要移动其它元素，时间复杂度低；

3. 定义时**长度可以不固定**，是动态的；

#### 缺点

1. 在动态添加元素时，如果vector长度不够容纳新元素，底层会开辟一块更大的新的空间，将原来数据复制过去，并在末尾添加新元素；如果频繁需要对vector进行操作，会消耗很多的系统资源；
2. 在vector头部或中间插入元素时，需要移动后续元素，时间复杂度为O(n),性能不好

#### 常用操作函数

- **增加**
  
  1. push_back(元素)：向数组末尾添加一个元素；
  2. insert(指定位置的迭代器，插入的值)：返回的是指向新插入元素的迭代器
  
- **删除**：
  
  1. pop_back()：删除数组中最后一个元素；
  2. `earse`(迭代器)：删除指定位置的元素；也可以通过std::remove- 结合earse或者pop_back的方法删除指定的元素，思路就是将要删除的元素移动到vector末尾，然后删除掉末尾的元素；
  3. clear()：清空数组；
  
- **访问元素：**返回的是访问的元素的**引用**，因此可以直接通过返回值对vector中该元素进行修改；

  1. at(下标)：访问指定位置的元素，相当于vector[下标]，但是at是安全的，会检查边界；

  ```
  vector<int> a{1,1,1,1,1}
  a.at(2) = 3;   //可以直接将a[2]的元素修改为3；
  int ele = a.at(2) //相对于将a[2]的值赋给ele，修改ele不会对a[2]产生影响；
  ```
  2. front()：访问第一个元素；
  3. back()：访问最后一个元素；
  4. data()：返回指向第一个元素的指针，得用指针来接收返回值；
  5. empty()：判断是否为空；

### 2. set(有序集合)：

- 内部使用**红黑树**实现，自动升序排列，不允许出现重复元素，支持快速增删改查；适用于对空间要求不高，且不经常修改的场景；

#### 优点

1. **有序性**和**唯一性**；
2. 因为基于红黑树实现，所以查找时比较快速，时间复杂度低；

#### 缺点

1. 同样也是因为红黑树，插入和删除元素效率低，因为涉及到红黑树的旋转和重新平衡；
2. 占用空间大，也是因为红黑树；

#### 常用操作函数

- **增加**
  1. insert(元素)：向集合中插入元素，会默认排序，因此不能指定位置；

- **删除**：
  1. erase(元素)：可以删除指定元素，因为set的唯一性不用考虑有多个元素的情况；
  2. clear()：清空集合；

- **查找：不能通过下标访问元素**
  1. `find`(元素)：查找指定元素，返回的是迭代器，如果查找失败，则返回指向集合末尾的迭代器；
  2. `cout`(元素)：返回指定元素个数，由于唯一性，返回值只有0和1，所以也相当于查找元素；

# 二、常见算法

## 1. 贪心算法

### 思想 

- 寻找局部最优解，所有的局部最优拼起来从而使得最后的全局是最优的；

### 例题

#### 1. 分饼干

- **题目描述：**根据孩子饭量的不同，将不同大小的饼干分给不同的孩子，让最多的孩子吃饱
- **思路：**争取用最小的饼干让饭量最小的孩子吃饱，循环直到饼干用完或孩子都吃饱
  - 1. 将饼干和孩子从小到大排序；
    2. 同时从第一个开始遍历两个数组，如果当前的饼干能让当前的孩子吃饱，继续循环，饼干和孩子都移动到下一个；如果当前的饼干不能，则将饼干移动到下一个，孩子不动；
    3. 可以使用while循环，当孩子或饼干有一个遍历结束后结束循环；

#### 2. 分糖果

- **题目描述：**有一排得分不同的孩子，给他们分糖果，两个相邻的孩子分数高的糖果数要多，并且每个孩子都至少要有一个，需要的糖果个数最少是？
- **思路：**从右到左遍历一遍，保证右边的比左边的分数高的人，糖果数也多，然后再同理从左到右遍历一遍；
  - 1. 首先给每个孩子各分配一个糖果；
    2. 然后从左到右遍历一遍，如果右边的孩子分数比左边的高，那该小孩的糖果数就在他左边的人的基础上多一个；
    3. 然后再从右向左遍历一遍，如果这个孩子左边的人分数比他高，并且糖果数少于或等于他的话，左边的孩子糖果数在他的基础上加一；

#### 3. 删除重叠区间

- **题目描述：**给定一个区间的集合 `intervals` ，其中 `intervals[i] = [starti, endi]` 。返回需要移除区间的最小数量，使剩余区间互不重叠；

- **思路：**将提供的区间按照**区间结尾的大小**进行排序（可以使用sort算法自定义排序方式），排序后选择第一个区间的结尾作为基区间，然后遍历比较，如果有哪个区间的头小于基区间的结尾，则区间重叠，需要移除

- **代码示例：** 

  ```c++
  	//自定义sort排序方法，也可使用lambda表达式编写匿名函数；
  	static bool cmp(const vector<int>& a, const vector<int>& b) {
          return a[1] < b[1];
      }
  
      int eraseOverlapIntervals(vector<vector<int>>& intervals) {
          if (intervals.size() == 0) {
              return 0;
          }
          // 对区间根据区间结尾排序，调用自定义的方法
          sort(intervals.begin(), intervals.end(), cmp);
          int result = 1;
          int pre = intervals[0][1];
          //从第二个区间开始遍历，如果后续有区间不需要删除，则将这个区间作为新的基区间
          for (int i = 1; i < intervals.size(); i++) {
              if (intervals[i][0] >= pre) {
                  result++;
                  pre = intervals[i][1];
              }
          }
          return intervals.size() - result;
      }
  ```

  

## 2. 双指针

### 思想：

- 一般用于遍历数组、链表来搜索匹配的值，可以是两个指针向相同方向搜素，或从相反的方向向中间搜素，也可以是多个数组和多个指针的情况；

### 例题：

#### 1. 两数之和

- **题目描述：**给定一个数组，找到和等于某个值的两个元素
- **思路：**
  - 方法一：暴力枚举：两层循环，外层从第一个开始，内层从外层的下一个开始遍历查找；时间复杂度为O(n^2)；
  - 方法二：哈希表法：创建一个哈希表，遍历数组，然后查找哈希表中是否有等于 target - nums[i] 的值，有的话返回当前值和哈希表中的值或下标，没有则将这个值和下标加入哈希表中；
  - 方法三：双指针遍历法（要求是有序的数组）：两个指针，分别从开头和末尾向中间遍历，比较每次遍历得到得值得和与target得大小，如果小于target，则左边的指针向右移动，如果大于target，则右边的指针向左移动；

#### 2. 合并两个有序数组

- **题目描述：** 将两个非递减排序的数组合并为一个；
- **思路：** 定义三个指针，分别指向两个原数组的末尾和新数组的末尾，将两个指针指向的大的一个放到新数组的末尾，然后将较大者的指针向前移；

#### 3. 找链表环路（快慢指针）

- **题目描述：**给定一个链表，如果有环路，找出环路的开始点。
- **思路：**使用快慢指针，快指针（2步）一定会在环内追上慢指针（1步），然后将快指针移动到起点变成一步向前走，快慢指针一定会在环入口相遇；
  1. 定义两个指针，一个快指针每次前进两步，慢指针每次前进一步；
  2. 同时从链表开头出发，如果没有环路，快指针会提前走到尽头；如果有环路，则会一直循环下去，并且终有一刻快慢指针会相遇；
  3. 第一次快慢指针相遇之后，将块指针重新移向开头，并且改为每次前进一步；
  4. 两个指针第二次相遇时，这个节点就是环路的起点；

#### 4.求包含子字符串的长度（滑动窗口）

- **题目描述：**给定两个字符串 S 和 T，求 S 中包含 T 所有字符的最短连续子字符串的长度，同时要求时间复杂度不得超过 O(n)。
- **思路：**

## 3.动态规划（DP）

### 思想：

- 将问题分解成子问题来解决（递推）；动态规划需要存储子问题的解，避免了碰到重复子问题重复计算，通过局部最优解来得到全局最优解；而贪心算法也是将问题分割成子问题，但是不需要存储子问题的解，贪心算法只考虑当前问题的最优解，不考虑对后面问题的影响，不能保证得到全局最优解，只适用于某些特定情况；
- 一般分为5个步骤：
  1. 创建DP数组，并搞清楚DP数组的下标和值的含义；
  2. 算出递推公式；
  3. DP数组初始化；
  4. 遍历，想清楚遍历顺序；
  5. 打印DP数组；

### 例题：

#### 1. 基础题

- 求斐波那契数列：数列中从第三个数开始每个数都等于前两个数相加；
- 爬楼梯：本质还是斐波那契数列；
- 使用最小花费爬楼梯
  - **题目描述：**给你一个整数数组 `cost` ，其中 `cost[i]` 是从楼梯第 `i` 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。你可以选择从下标为 `0` 或下标为 `1` 的台阶开始爬楼梯。请你计算并返回达到楼梯顶部的最低花费。
  - **思路：** 
    1. 定义`dp`数组，`dp`数组的长度是`const`的长度+1；因为若给出0，1，2三阶的花费，则顶楼是台阶3；
    2. 递推公式为`dp[i] = min(dp[i-1] +cost[i-1],dp[i-2] +cost[i-2])`; 该台阶前的花费加上从该台阶跳上去的花费；
- 求从起点到终点有多少种不同路径
  - **题目描述：**从一个 `m x n` 网格的左上角，每次只能向下或者向右移动一步。达到网格的右下角总共有多少条不同的路径？
  - **思路：** 
    1. 定义一个二维的`dp`数组，`dp`数组的下标`i`,`j`表示节点的坐标，值为到该节点的路径数；
    2. 如何初始化：因为只能向右或向下移动，因此`dp[0][j]`(即最上面一行)和`dp[i][0]`(即最左边一列)的值都是1，即只能有一种路径；
    3. 递推公式为`dp[i][j] = dp[i-1][j]+dp[i][j-1]`，因为位于中间的任何一个格子，只能由该格子上方或左边到达；

#### 2.背包问题





## 4.查找算法（不考虑稳定性）

### 1. 顺序查找

- **思想：**从头开始遍历查找某个值；
- **复杂度：**时间复杂度O(n)，空间复杂度O(1)；

### 2. 二分查找

- **要求：**数组必须是有序的

- **思想：** 把数组一分为二，找到目标值所在的范围后再次一分为二，直到找到目标值；
- **复杂度：**时间复杂度O(log(n))，空间复杂度O(1)；

### 3. 插值查找

- **要求：**由于插值查找是一种改进的二分查找，针对**数组有序且分布均匀**的情况，效率比二分查找更高；
- **思想：**也是通过缩小范围来查找目标值，但不是像二分查找一样每次从中间分开，而是根据**插值公式**找到目标值可能出现的位置，从该位置进行划分，在数据均匀分布的情况下，相比二分查找，减少了划分的次数；插值公式一般如下：<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240430125528824.png" alt="image-20240430125528824" style="zoom:50%;" />
- 复杂度：与二分查找相同，时间复杂度O(log(n))，空间复杂度O(1)；

### 4. 斐波那契查找

- **要求：**要求数组有序；
- **思想：**也是通过不断地缩小范围进行查找，只是计算mid(分割点)的方式不同，用黄金分割点来进行查找；
- **复杂度：**与二分查找相同，时间复杂度O(log(n))，空间复杂度O(1)；

### 5. 分块查找

- **要求：**块内无序，但是要求块与块之间是有序的，即：前一块中的最大数据，小于后一块中的所有数据

- **思想：**先选取各块中的最大关键字构成一个索引表，然后查找索引表找到要查找的数据在哪块，然后再在块中进行查找；
- 复杂度：<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240430130729323.png" alt="image-20240430130729323" style="zoom:80%;" />

### 6. 哈希查找





## 5. 排序算法（考虑稳定性）

- 稳定性的概念：算法稳定性指的是当输入数据中存在**相同的元素**时，算法是否能够保持这些元素之间的**相对顺序不变**

### 1. 选择排序

- **思想：**从前往后，找整个数组中的最值，放到第一位，然后第一位不到，找后面的最大值，放到第二位；每次都**选择**剩余数组中的**最值**，从前向后放；`i：0->len-1`，`j：i+1->len-1`,用i和最小值交换；
- **复杂度：**时间复杂度O(n^2)；空间复杂度O(1);
- **稳定性：**不稳定；

### 2. 冒泡排序

- **思想：**从第一个数开始与第二个比较交换，然后第二个与第三个比较交换，直到倒数第二与倒数第一比较交换，将最后一位变为最大/小值。然后再从第一个开始，循环交换，将倒数第二个变为该轮的最大/小值，以此类推；`j：0 -> i-1`，`i：len -> 1`，j与j+1交换；
- **复杂度：**时间复杂度O(n^2)；空间复杂度O(1);
- **稳定性：**不稳定；
- **优化方法：**再经过几轮排序之后，若已实现有序，再后续不需要再进行循环；可以设一个flag，默认为true，进行一次交换则变为false；在每一轮循环结束后判断一次flag，若仍为true，则本次循环未发生交换，即前面的已经有序，可以提前结束循环；

### 3. 插入排序

- **思想：**将数据分为有序区和无序区，从无序区第一个数开始，将其插入到有序区中（遍历有序区，找到位置，将后面的数全部后移）；总共**三层循环**，第一层循环无序区，拿到一个之后遍历有序区寻找插入位置，找到位置之后遍历该位置后面的将其后移（后移时要从后往前移）；
- **复杂度：**时间复杂度O(n^2)；空间复杂度O(1);
- **稳定性：**稳定；
- **优化方法：**希尔排序

### 4. 希尔排序

- **思想：**设定一个gap（一般从n/2开始），将数据按gap进行分组，然后对每组再进行插入排序，接着缩小gap，循环直到gap为1，即最后一次是对所有数据进行插入排序；
- **复杂度：**时间复杂度(O(n \log n)) 到 (O(n^2)) 之间，空间复杂度O(1)；
- **稳定性：**稳定；

### 5. 计数排序

- **思想：**一种简单的桶排序；新建一个数组b作为桶，统计原数组a中每个元素i出现的次数，将次数记录到数组b[i]中；然后循环打印数组b的下标i，每个下标打印b[i]次；适用于数组范围小的情况，否则数组b会很大；
- **复杂度：**时间复杂度O(n)，空间复杂度O(n);
- **稳定性：**稳定；

### 6. 桶排序

- 思想：建立若干个桶，每个桶只存储固定范围的数，然后遍历目标数组将其依次放入桶中，最后对所有不为空的桶进行排序(可选任意方法)，最后再按桶的顺序依次输出；
- 复杂度：时间复杂度O(n)，空间复杂度O(n);
- 稳定性：不稳定；

### 7. 快速排序

- 思想：
- 复杂度：
- 稳定性：

### 8. 堆排序

- 思想：
- 复杂度：
- 稳定性：

### 9. 归并排序

- 思想：
- 复杂度：
- 稳定性：

## 6. 二叉树

- 分类：
  1. 满二叉树：每个节点要嘛没有子节点，要嘛有两个子节点；
  2. 完全二叉树：最底层节点，从左到右是连续的；满二叉树一定是完全二叉树；
  3. 二叉搜索树：左子树的所有节点都小于有子树的所有节点；便于搜素，搜素每个节点的时间复杂度为log(n)，向里插入一个节点的时间复杂度也是log(n);
  4. 平衡二叉搜素树：左子树与右子树的高度差小于等于`1`的二叉搜素树；
  4. 红黑树：改进的平衡二叉树，遵循红黑规则；
  4. 哈夫曼树：
- 遍历方式
  - 深度优先搜素DFS（一般通过**递归或者栈**来实现）
    1. 前序遍历：中 -> 左 -> 右。
    2. 中序遍历： 左 -> 中 -> 右。
    3. 后序遍历： 左 -> 右 -> 根。
  - 广度优先搜素BFS（一般通过**迭代或队列**来实现）
    1. 层序遍历：一层层从上往下遍历
- 平衡二叉树的旋转：
  - 左旋：
  - 右旋：

- 红黑树规则：
  1. 根节点必须是黑色；
  2. 如果一个节点没有子节点或者父节点，则该节点相应的指针属性值为`Nil`,这些`Nil`视为叶节点，每个业节点是黑色的；
  3. 不能出现两个红色节点相连的情况，即若某个节点是红色，那么其子节点必须是黑色的；、
  4. 对每一个节点，从该节点到其后代叶节点的简单路径上，均包含相同数目的黑色节点；
  5. 添加节点时，要添加的节点默认每个颜色是红色