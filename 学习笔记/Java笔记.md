###  集合

#### 分类：

- **单列集合（Collection）**：单列集合的祖宗接口
  1. List：存储的元素可重复、有索引，包括：`ArrayList`、`LinkedList`
  2. set：存储的元素不可重复，没有索引：`HashSet`( `LinkedHashSet` )、`TreeSet`
- **双列集合（Map）**：双列集合的祖宗接口
  1. 

#### 常用API

- Arraylist
  1. 增加
  2. 删除
  3. 修改
- LinkedList
  1. 增加：
     - addfirst(元素)：在列表开头插入指定元素；
     - addLast(元素)：在列表末尾添加指定元素；
  2. 获取元素：
     - getFirst()：返回首元素；
     - getLast()：返回末尾元素；
  3. 删除：
     - removeFirst()：删除首元素并返回该元素；
     - removeLast()：删除尾元素并返回该元素；
- HashSet：无序；底层是哈希表结构，由数组+链表+红黑树构成
- LinkedHashSet：有序(存和取的顺序是一致的)；底层在哈希表的基础上添加了双向链表的机制进行存储；
- TreeSet：有序；底层基于红黑树实现，可以自己指定比较规则

注意事项：

1. Java中的泛型是伪泛型；只在编译时有用；泛型中不能写基本数据类型
2. 泛型的通配符`？`
2. 可变参数：方法形参中只能有一个可变参数，并且可变参数要放在形参列表的最后；
2. Java中字符串是不可变的，因此不能通过String.charAt()来修改字符串中的内容；而C++中中的字符串是可变的
2. `StringBuilder`是线程不安全的，`StringBuffer`是线程安全的;



### 多线程

#### 三种实现方法：

**1.  继承Thread：**用当前类继承Thread类，并重写run()方法；

**2.  实现Runnable接口：**用当前类实现Runnable接口，并重新run()方法；然后创建Thread对象，参数传递当前类对象；该方法中当前类对象即是一个任务对象，运行即是通过Thread调用该任务；

**3.  实现Callable接口：**用当前类实现Callable接口，重写call()方法；call方法会有返回值，该实现方法可以获取到多线程执行的结果；

### 守护线程

- 当其它非守护线程结束之后，守护线程就算没有执行完，也会陆陆续续结束，但不是马上结束；

### 线程锁

- **`synchronized`关键字（锁对象）**:锁住临界区
- 将`synchronized`加在方法上，会将整个方法锁住；
- lock锁：需要手动上锁和释放锁；