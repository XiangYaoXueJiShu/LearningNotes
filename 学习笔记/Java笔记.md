## 面试常见问题

### 1. Java和C++的区别

- Java不提供指针，不能直接访问内存，程序内存更加安全；
- Java中的类只能单继承，不支持多重继承；但是接口可以多继承；
- Java有自定内存管理回收机制（`GC`），不需要手动释放内存；
- C++支持方法重载和运算符重载，Java 只支持方法重载；

### 2.标识符和关键字的区别

- 标识符其实就是名字，类名，方法名等；对于具有特殊意义的标识符我们将其称之为关键字



## 基础语法

### 1. 移位运算符

- 数据会被看作二进制数进行运算，使用移位运算符比使用普通运算**更加高效**；`double`、`float`不能进行移位运算；对于`char`,`short`,`byte`等类型，Java在进行移位运算时都会先转为int再进行操作；所以真正可以进行移位操作的只有`int`和`long`；

- `<<`：**左移**；高位丢弃，低位补零；`x << 1`,相当于 x 乘以 2(不溢出的情况下)。
- `>>`：**带符号右移**；向右移若干位，高位补符号位，低位丢弃，正数高位补 0，负数高位补 1；`x >> 1`,相当于 x 除以 2。
- `>>>`：**无符号右移**；忽略符号位，空位都以 0 补齐；

#### 2. 基本数据类型和对应的包装类

- 基本类型不能用于泛型，包装类可以；

- 基本类型的局部变量存放于**栈**中，**但是基本类型的成员变量或者被static修饰，也是存放在堆中的**；而包装类是对象类型，其所有变量都存放于堆中；

- 对于基本数据类型来说，`==` 比较的是值。对于包装数据类型来说，`==` 比较的是对象的**内存地址**。

- **浮点数运算问题：**

  - 计算机在进行浮点数运算时，是将数值转换为二进制数，但是一些小数转换为二进制的长度是无穷的，所以会进行截断保存；

  - 解决这个问题，需要使用`BigDecimal`类， 可以实现对浮点数的运算，不会造成精度丢失；

- **整数溢出问题：**

  - long的最大长度为64位，对于长度超出64位的整形数据，可以使用`BigInteger`类解决，其内部使用`int[]`表示任意长度的整形数据，但是运算效率会比较低；











###  集合

#### 分类：

- **单列集合（Collection）**：单列集合的祖宗接口
  1. List：存储的元素可重复、有索引，包括：`ArrayList`、`LinkedList`
  2. set：存储的元素不可重复，没有索引：`HashSet`( `LinkedHashSet` )、`TreeSet`
- **双列集合（Map）**：双列集合的祖宗接口
  1. 

#### 常用API

- Arraylist
  1. 增加
  2. 删除
  3. 修改
- LinkedList
  1. 增加：
     - addfirst(元素)：在列表开头插入指定元素；
     - addLast(元素)：在列表末尾添加指定元素；
  2. 获取元素：
     - getFirst()：返回首元素；
     - getLast()：返回末尾元素；
  3. 删除：
     - removeFirst()：删除首元素并返回该元素；
     - removeLast()：删除尾元素并返回该元素；
- HashSet：无序；底层是哈希表结构，由数组+链表+红黑树构成
- LinkedHashSet：有序(存和取的顺序是一致的)；底层在哈希表的基础上添加了双向链表的机制进行存储；
- TreeSet：有序；底层基于红黑树实现，可以自己指定比较规则

注意事项：

1. Java中的泛型是伪泛型；只在编译时有用；泛型中不能写基本数据类型
2. 泛型的通配符`？`
2. 可变参数：方法形参中只能有一个可变参数，并且可变参数要放在形参列表的最后；
2. Java中字符串是不可变的，因此不能通过String.charAt()来修改字符串中的内容；而C++中中的字符串是可变的
2. `StringBuilder`是线程不安全的，`StringBuffer`是线程安全的;
2. `char`类型在Java中占两个字节；



### 多线程

#### 三种实现方法：

**1.  继承Thread：**用当前类继承Thread类，并重写run()方法；

**2.  实现Runnable接口：**用当前类实现Runnable接口，并重新run()方法；然后创建Thread对象，参数传递当前类对象；该方法中当前类对象即是一个任务对象，运行即是通过Thread调用该任务；

**3.  实现Callable接口：**用当前类实现Callable接口，重写call()方法；call方法会有返回值，该实现方法可以获取到多线程执行的结果；

### 守护线程

- 当其它非守护线程结束之后，守护线程就算没有执行完，也会陆陆续续结束，但不是马上结束；

### 线程锁

- **`synchronized`关键字（锁对象）**:锁住临界区
- 将`synchronized`加在方法上，会将整个方法锁住；
- lock锁：需要手动上锁和释放锁；